-- SQL CREATE statements for Approval System Database Schema

-- Table: APP_REQUESTS
CREATE TABLE APP_REQUESTS (
    REQUEST_ID          NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    REQUEST_TYPE        VARCHAR2(100) NOT NULL,
    REQUEST_DESCRIPTION VARCHAR2(4000),
    REQUESTOR_ID        NUMBER NOT NULL,
    REQUEST_DATE        DATE DEFAULT SYSDATE NOT NULL,
    STATUS              VARCHAR2(50) DEFAULT 'Pending' NOT NULL,
    CURRENT_APPROVER_ID NUMBER,
    REMARKS             VARCHAR2(4000)
);

-- Table: APP_APPROVAL_CYCLE
CREATE TABLE APP_APPROVAL_CYCLE (
    APPROVAL_ID         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    REQUEST_ID          NUMBER NOT NULL,
    APPROVER_ID         NUMBER NOT NULL,
    APPROVAL_ORDER      NUMBER NOT NULL,
    STATUS              VARCHAR2(50) DEFAULT 'Pending' NOT NULL,
    APPROVAL_DATE       DATE,
    COMMENTS            VARCHAR2(4000),
    CONSTRAINT FK_REQUEST_ID FOREIGN KEY (REQUEST_ID) REFERENCES APP_REQUESTS(REQUEST_ID)
);

-- Table: USERS
CREATE TABLE USERS (
    USER_ID             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    USERNAME            VARCHAR2(100) UNIQUE NOT NULL,
    PASSWORD_HASH       VARCHAR2(255) NOT NULL,
    EMAIL               VARCHAR2(255) UNIQUE,
    FULL_NAME           VARCHAR2(255),
    CREATED_DATE        DATE DEFAULT SYSDATE NOT NULL
);

-- Table: ROLES
CREATE TABLE ROLES (
    ROLE_ID             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    ROLE_NAME           VARCHAR2(100) UNIQUE NOT NULL
);

-- Table: USER_ROLES
CREATE TABLE USER_ROLES (
    USER_ID             NUMBER NOT NULL,
    ROLE_ID             NUMBER NOT NULL,
    CONSTRAINT PK_USER_ROLES PRIMARY KEY (USER_ID, ROLE_ID),
    CONSTRAINT FK_USER_ROLES_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID),
    CONSTRAINT FK_USER_ROLES_ROLE FOREIGN KEY (ROLE_ID) REFERENCES ROLES(ROLE_ID)
);

-- Add foreign key constraints to APP_REQUESTS and APP_APPROVAL_CYCLE for USERS table
ALTER TABLE APP_REQUESTS
ADD CONSTRAINT FK_REQUESTOR_ID FOREIGN KEY (REQUESTOR_ID) REFERENCES USERS(USER_ID);

ALTER TABLE APP_REQUESTS
ADD CONSTRAINT FK_CURRENT_APPROVER_ID FOREIGN KEY (CURRENT_APPROVER_ID) REFERENCES USERS(USER_ID);

ALTER TABLE APP_APPROVAL_CYCLE
ADD CONSTRAINT FK_APPROVER_ID FOREIGN KEY (APPROVER_ID) REFERENCES USERS(USER_ID);






-- PL/SQL Package: PKG_APPROVAL_PROCESS
CREATE OR REPLACE PACKAGE PKG_APPROVAL_PROCESS AS

    PROCEDURE SUBMIT_REQUEST (
        p_request_type        IN VARCHAR2,
        p_request_description IN VARCHAR2,
        p_requestor_id        IN NUMBER,
        p_first_approver_id   IN NUMBER,
        p_request_id          OUT NUMBER
    );

    PROCEDURE PROCESS_APPROVAL (
        p_approval_id IN NUMBER,
        p_approver_id IN NUMBER,
        p_action      IN VARCHAR2, -- 'Approve' or 'Reject'
        p_comments    IN VARCHAR2
    );

    PROCEDURE REQUEST_MORE_INFORMATION (
        p_request_id IN NUMBER,
        p_approver_id IN NUMBER,
        p_comments   IN VARCHAR2
    );

    PROCEDURE CREATE_APPROVAL_CYCLE (
        p_request_id IN NUMBER,
        p_approvers  IN VARCHAR2 -- Comma-separated list of approver USER_IDs
    );

    FUNCTION GET_CURRENT_APPROVER (
        p_request_id IN NUMBER
    ) RETURN NUMBER;

    FUNCTION IS_REQUEST_APPROVED (
        p_request_id IN NUMBER
    ) RETURN BOOLEAN;

    FUNCTION IS_REQUEST_REJECTED (
        p_request_id IN NUMBER
    ) RETURN BOOLEAN;

END PKG_APPROVAL_PROCESS;
/

CREATE OR REPLACE PACKAGE BODY PKG_APPROVAL_PROCESS AS

    PROCEDURE SEND_STATUS_EMAIL (
        p_request_id IN NUMBER,
        p_status     IN VARCHAR2,
        p_comments   IN VARCHAR2
    ) AS
        v_requestor_email VARCHAR2(255);
        v_request_description VARCHAR2(4000);
        v_approver_name VARCHAR2(255);
        v_email_subject VARCHAR2(255);
        v_email_body CLOB;
    BEGIN
        -- Get requestor's email and request description
        SELECT u.EMAIL, r.REQUEST_DESCRIPTION
        INTO v_requestor_email, v_request_description
        FROM APP_REQUESTS r
        JOIN USERS u ON r.REQUESTOR_ID = u.USER_ID
        WHERE r.REQUEST_ID = p_request_id;

        -- Get the name of the last approver
        SELECT u.FULL_NAME
        INTO v_approver_name
        FROM APP_APPROVAL_CYCLE ac
        JOIN USERS u ON ac.APPROVER_ID = u.USER_ID
        WHERE ac.REQUEST_ID = p_request_id
        AND ac.STATUS = p_status
        AND ROWNUM = 1;

        v_email_subject := 'Your Request #' || p_request_id || ' has been ' || p_status;

        v_email_body := 'Dear Requestor,' || UTL_TCP.CRLF || UTL_TCP.CRLF;
        v_email_body := v_email_body || 'Your request has been ' || p_status || '.' || UTL_TCP.CRLF || UTL_TCP.CRLF;
        v_email_body := v_email_body || 'Request ID: ' || p_request_id || UTL_TCP.CRLF;
        v_email_body := v_email_body || 'Description: ' || v_request_description || UTL_TCP.CRLF;
        v_email_body := v_email_body || 'Action taken by: ' || v_approver_name || UTL_TCP.CRLF;
        v_email_body := v_email_body || 'Comments: ' || p_comments || UTL_TCP.CRLF;
        v_email_body := v_email_body || UTL_TCP.CRLF || 'Thank you.';

        IF v_requestor_email IS NOT NULL THEN
            APEX_MAIL.SEND(
                p_to   => v_requestor_email,
                p_from => 'noreply@yourapp.com', -- Change to a valid sender email
                p_subj => v_email_subject,
                p_body => v_email_body
            );
        END IF;

    EXCEPTION
        WHEN OTHERS THEN
            -- Handle exceptions, maybe log the error
            NULL;
    END SEND_STATUS_EMAIL;

    PROCEDURE SUBMIT_REQUEST (
        p_request_type        IN VARCHAR2,
        p_request_description IN VARCHAR2,
        p_requestor_id        IN NUMBER,
        p_first_approver_id   IN NUMBER,
        p_request_id          OUT NUMBER
    ) AS
    BEGIN
        INSERT INTO APP_REQUESTS (
            REQUEST_TYPE,
            REQUEST_DESCRIPTION,
            REQUESTOR_ID,
            STATUS,
            CURRENT_APPROVER_ID
        ) VALUES (
            p_request_type,
            p_request_description,
            p_requestor_id,
            'Pending',
            p_first_approver_id
        ) RETURNING REQUEST_ID INTO p_request_id;

        -- Automatically create the first step in the approval cycle
        INSERT INTO APP_APPROVAL_CYCLE (
            REQUEST_ID,
            APPROVER_ID,
            APPROVAL_ORDER,
            STATUS
        ) VALUES (
            p_request_id,
            p_first_approver_id,
            1,
            'Pending'
        );

        COMMIT;
    END SUBMIT_REQUEST;

    PROCEDURE PROCESS_APPROVAL (
        p_approval_id IN NUMBER,
        p_approver_id IN NUMBER,
        p_action      IN VARCHAR2,
        p_comments    IN VARCHAR2
    ) AS
        v_request_id NUMBER;
        v_current_approver_id NUMBER;
        v_next_approver_id NUMBER;
        v_approval_order NUMBER;
        v_next_approval_order NUMBER;
    BEGIN
        -- Get request_id and approval_order for the current approval
        SELECT REQUEST_ID, APPROVAL_ORDER
        INTO v_request_id, v_approval_order
        FROM APP_APPROVAL_CYCLE
        WHERE APPROVAL_ID = p_approval_id
        AND APPROVER_ID = p_approver_id
        FOR UPDATE;

        -- Update the current approval step
        UPDATE APP_APPROVAL_CYCLE
        SET
            STATUS = p_action,
            APPROVAL_DATE = SYSDATE,
            COMMENTS = p_comments
        WHERE APPROVAL_ID = p_approval_id;

        IF p_action = 'Approve' THEN
            -- Check if there are more approvers in the cycle
            v_next_approval_order := v_approval_order + 1;

            BEGIN
                SELECT APPROVER_ID
                INTO v_next_approver_id
                FROM APP_APPROVAL_CYCLE
                WHERE REQUEST_ID = v_request_id
                AND APPROVAL_ORDER = v_next_approval_order;

                -- If there's a next approver, update the request's current approver
                UPDATE APP_REQUESTS
                SET CURRENT_APPROVER_ID = v_next_approver_id
                WHERE REQUEST_ID = v_request_id;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    -- No more approvers, request is fully approved
                    UPDATE APP_REQUESTS
                    SET STATUS = 'Approved',
                        CURRENT_APPROVER_ID = NULL
                    WHERE REQUEST_ID = v_request_id;

                    -- Send email notification
                    SEND_STATUS_EMAIL(v_request_id, 'Approved', p_comments);

            END;
        ELSIF p_action = 'Reject' THEN
            -- If rejected, update the main request status
            UPDATE APP_REQUESTS
            SET STATUS = 'Rejected',
                CURRENT_APPROVER_ID = NULL
            WHERE REQUEST_ID = v_request_id;

            -- Send email notification
            SEND_STATUS_EMAIL(v_request_id, 'Rejected', p_comments);
        END IF;

        COMMIT;
    END PROCESS_APPROVAL;

    PROCEDURE REQUEST_MORE_INFORMATION (
        p_request_id IN NUMBER,
        p_approver_id IN NUMBER,
        p_comments   IN VARCHAR2
    ) AS
    BEGIN
        UPDATE APP_REQUESTS
        SET STATUS = 'Pending Information',
            REMARKS = p_comments
        WHERE REQUEST_ID = p_request_id;

        -- Optionally, send a notification to the requestor
        -- For now, just updating the status and remarks

        COMMIT;
    END REQUEST_MORE_INFORMATION;

    PROCEDURE CREATE_APPROVAL_CYCLE (
        p_request_id IN NUMBER,
        p_approvers  IN VARCHAR2
    ) AS
        l_approver_id NUMBER;
        l_approval_order NUMBER := 1;
        l_approver_list APEX_T_VARCHAR2;
    BEGIN
        -- Clear existing approval cycle for the request if any
        DELETE FROM APP_APPROVAL_CYCLE WHERE REQUEST_ID = p_request_id;

        l_approver_list := APEX_STRING.SPLIT(p_approvers, ',');

        FOR i IN 1..l_approver_list.COUNT LOOP
            l_approver_id := TO_NUMBER(TRIM(l_approver_list(i)));

            INSERT INTO APP_APPROVAL_CYCLE (
                REQUEST_ID,
                APPROVER_ID,
                APPROVAL_ORDER,
                STATUS
            ) VALUES (
                p_request_id,
                l_approver_id,
                l_approval_order,
                'Pending'
            );
            l_approval_order := l_approval_order + 1;
        END LOOP;

        -- Update the main request with the first approver
        IF l_approver_list.COUNT > 0 THEN
            UPDATE APP_REQUESTS
            SET CURRENT_APPROVER_ID = TO_NUMBER(TRIM(l_approver_list(1)))
            WHERE REQUEST_ID = p_request_id;
        END IF;

        COMMIT;
    END CREATE_APPROVAL_CYCLE;

    FUNCTION GET_CURRENT_APPROVER (
        p_request_id IN NUMBER
    ) RETURN NUMBER IS
        v_approver_id NUMBER;
    BEGIN
        SELECT CURRENT_APPROVER_ID
        INTO v_approver_id
        FROM APP_REQUESTS
        WHERE REQUEST_ID = p_request_id;

        RETURN v_approver_id;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END GET_CURRENT_APPROVER;

    FUNCTION IS_REQUEST_APPROVED (
        p_request_id IN NUMBER
    ) RETURN BOOLEAN IS
        v_status VARCHAR2(50);
    BEGIN
        SELECT STATUS
        INTO v_status
        FROM APP_REQUESTS
        WHERE REQUEST_ID = p_request_id;

        RETURN (v_status = 'Approved');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN FALSE;
    END IS_REQUEST_APPROVED;

    FUNCTION IS_REQUEST_REJECTED (
        p_request_id IN NUMBER
    ) RETURN BOOLEAN IS
        v_status VARCHAR2(50);
    BEGIN
        SELECT STATUS
        INTO v_status
        FROM APP_REQUESTS
        WHERE REQUEST_ID = p_request_id;

        RETURN (v_status = 'Rejected');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN FALSE;
    END IS_REQUEST_REJECTED;

END PKG_APPROVAL_PROCESS;
/

-- Authorization Scheme: IS_APPROVER
-- This scheme checks if the current user is an approver for any pending request.
-- You would typically link this to a user role or a specific approver table.
-- For this example, we'll assume a simple check against the USERS table for demonstration.
-- In a real application, you'd likely have a more sophisticated role-based access control.

-- Example of a simple authorization scheme (to be created manually in APEX or via APEX API calls)
-- This cannot be directly added to the SQL export in a runnable way without APEX API calls.
-- For demonstration, consider this as a conceptual placeholder.

-- You would create an Authorization Scheme in APEX with the following PL/SQL Function Body:
-- DECLARE
--    l_count NUMBER;
-- BEGIN
--    SELECT COUNT(1)
--    INTO l_count
--    FROM APP_APPROVAL_CYCLE ac
--    JOIN APP_REQUESTS ar ON ac.REQUEST_ID = ar.REQUEST_ID
--    WHERE ac.APPROVER_ID = :APP_USER_ID -- Assuming :APP_USER_ID holds the current user's ID
--    AND ac.STATUS = 'Pending'
--    AND ar.STATUS = 'Pending';
--
--    IF l_count > 0 THEN
--        RETURN TRUE;
--    ELSE
--        RETURN FALSE;
--    END IF;
-- END;

-- For a more robust authorization, you would manage roles and user assignments.
-- Example: Function to check if a user has a specific role
CREATE OR REPLACE FUNCTION HAS_ROLE (
    p_username IN VARCHAR2,
    p_role_name IN VARCHAR2
) RETURN BOOLEAN IS
    l_count NUMBER;
BEGIN
    SELECT COUNT(1)
    INTO l_count
    FROM USERS u
    JOIN USER_ROLES ur ON u.USER_ID = ur.USER_ID
    JOIN ROLES r ON ur.ROLE_ID = r.ROLE_ID
    WHERE u.USERNAME = p_username
    AND r.ROLE_NAME = p_role_name;

    RETURN (l_count > 0);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN FALSE;
END HAS_ROLE;
/
